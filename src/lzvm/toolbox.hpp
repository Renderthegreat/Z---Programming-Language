#include <cstdarg>
#include <iomanip>
#include <iostream>
#include <string>
#include <vector>

// Part of the external project LLAMA Z VIRTUAL MACHINE

#ifndef ZXVK_HPP
#define ZXVK_HPP

using namespace std;

#define ZREG(pos) REG(pos)
#define ZBREG(byte) REG((int)byte)

/*
 *	Type Definitions
 */

typedef std::string LZString;

class REG {
  public:
	REG(int val) { value = val; };
	int value;
};

class SUPERPAIRS {
  public:
	void add(LZString label) {
		position++;
		readable.push_back(label);
		formal.push_back(position);
	};
	int position;
	vector<LZString> readable;
	vector<int> formal;
};

enum ListSizeType { SIZED, UNLIMITED, NONE };

enum ClassPropertyType { PUBLIC, PRIVATE, STATIC };

LZString classpropertytypestring(ClassPropertyType classPropertyType) {
	switch (classPropertyType) {
	case PUBLIC:
		return "public";

	case PRIVATE:
		return "private";

	case STATIC:
		return "static";
	};
	return "";
}

/*
 *  Useful Stuff
 */

template <typename T> LZString inthex(T i) {
	std::stringstream stream;
	stream << "0x" << std::setfill('0') << std::setw(sizeof(T) * 2) << std::hex
	       << i;
	return stream.str();
};

/*
 *  Assembly Builder
 */

class AssemblyBuilder {
  public:
	AssemblyBuilder(LZString file, int top) {
		if (top == 0) {
			this->head +=
			    "#								"
			    "								"
			    "	  #"
			    "\n"
			    "# Sent from " +
			    file +
			    " City.							"
			    "		  #"
			    "\n"
			    "# Generated By Llama Z Toolbox.				"
			    "			  #"
			    "\n"
			    "#								"
			    "								"
			    "	  #"
			    "\n"
			    "# Dear User,							"
			    "							#"
			    "\n"
			    "# Thank you for using my compiler, it means a lot to  #"
			    "\n"
			    "# me! This is an open source project from Renderlabs  #"
			    "\n"
			    "# and since I made this compiler for you I give you	#"
			    "\n"
			    "# one thing to consider: Please use this language	  #"
			    "\n"
			    "# for open-source if possible. Remember, you make the #"
			    "\n"
			    "# internet better for everyone by sharing!			"
			    "	#"
			    "\n"
			    "# - Brendan Lucas from Renderlabs co				"
			    "		#"
			    "\n"
			    "#								"
			    "								"
			    "	  #"
			    "\n"
			    "#include \"zs.h\""
			    "\n";
			this->bss += ".bss"
			             "\n";
			this->data += ".data"
			              "\n";
			this->evaluated += ".text"
							   "\n";
		}
	};
	class ListType {
	  public:
		ListType(ListSizeType listType, int length = 0) {
			switch (listType) {
			case SIZED:
				size = length;
				type = SIZED;
				break;

			case UNLIMITED:
				type = UNLIMITED;
				break;
			case NONE:
				size = 1;
				type = NONE;
				break;
			}
		};
		int size;
		ListSizeType type;
	};
	class Type {
	  public:
		Type(LZString name, ListType *list, AssemblyBuilder *ctx) {
			if (name == "byte") {
				size = 1;
				direct = true;
			} else {
				size = 0;
				direct = false;
			}

			this->name = name;
			this->list = list;
			this->builder = ctx;
		};

		Type *addProperty(LZString label, Type *type) {
			size++;
			SuperPairProperties.add(label);
			SuperPairTypes.add(type->name);
			return this;
		};

		void lock() {
			locked = true;
			LZString text = "	t_size_" + name + " = " + inthex(size) + "\n";
			builder->data += text;
		};

		void relock() {
			if (!locked) {
				this->lock();
			}
		};

		SUPERPAIRS getProperties() {
			if (!locked) {
				cout << "Attempted to use type before type was locked!\n";
				exit(1);
			}
			return SuperPairProperties;
		};

		bool locked;
		bool direct;
		LZString name;
		Type *alias;
		int size;
		ListType *list;

	  private:
		SUPERPAIRS SuperPairProperties;
		SUPERPAIRS SuperPairTypes;
		AssemblyBuilder *builder;
	};
	Type *TypeGet(LZString name) {
		for (auto i = 0; i < (signed)types.size(); i++) {
			if (types[i]->name == name) {
				return types[i];
			}
		}
		return TypeGet("void");
	};
	class Variable {
	  public:
		Variable(LZString name, Type *type) {
			this->name = name;
			this->type = type;
		};
		LZString name;
		Type *type;
	};
	class Class {
	  public:
		Class(LZString name, AssemblyBuilder *ctx) {
			this->name = name;
			builder = ctx;
		};
		Class *addProperty(LZString label, Type *type,
		                   ClassPropertyType propertyType) {
			size++;
			SuperPairProperties.add(label);
			SuperPairTypes.add(type->name);
			SuperPairPropertyTypes.add(classpropertytypestring(propertyType));
			return this;
		};
		LZString name;
		int size;

	  private:
		SUPERPAIRS SuperPairProperties;
		SUPERPAIRS SuperPairTypes;
		SUPERPAIRS SuperPairPropertyTypes;
		AssemblyBuilder *builder;
	};
	class Function {
	  public:
		Function(LZString name, Type *type, AssemblyBuilder *ctx) {
			this->name = name;
			funcType = type;
			evaluated += ".global"
			             " " +
			             this->name +
			             "\n"
			             "\n" +
			             this->name +
			             ":"
			             "\n";
			instruction(InstructionType::FUNCSTACK, 1, ZREG(4));
			builder = ctx;
			return;
		};
		class FuncStack {
		  public:
			FuncStack(REG reg1) { registers.push_back(reg1); };
			vector<REG> registers;
		};
		class FuncStackClean {
		  public:
			FuncStackClean() {

			};
			vector<REG> registers;
		};
		class VariableInitiation {
		  public:
			VariableInitiation(REG reg1, AssemblyBuilder *ctx) {
				registers.push_back(reg1);
				builder = ctx;
			};
			AssemblyBuilder *builder;
			vector<REG> registers;
		};
		class BytePush {
		  public:
			BytePush(REG reg1) { registers.push_back(reg1); };
			vector<REG> registers;
		};
		enum InstructionType {
			MOVE,
			FUNCSTACK,
			FUNCSTACKCLEAN,
			VARINITIATION,
			ADD,
			SUBTRACT,
			MULTIPLY,
			DIVIDE
		};
		class Instruction {
		  public:
			Instruction(FuncStack *funcStack) {
				evaluated += "	POOL CREATE"
				             "\n";
			};
			Instruction(FuncStackClean *funcStackClean) {

			};
			Instruction(VariableInitiation *variableInitiation) {

			};
			Instruction(Class *class_) {

			};
			Instruction(BytePush *bytePush) {

			};
			LZString evaluated;
		};
		void instruction(InstructionType instructionType, int count, ...) {
			Instruction *instruction;
			va_list vregs;
			vector<REG> regs;
			va_start(vregs, count);
			for (auto i = 0; i < count; ++i) {
				regs.push_back(va_arg(vregs, REG));
			}
			switch (instructionType) {
			case FUNCSTACK:
				if (count != 1) {
					cout << "Incorrect number of REGISTERS for FUNCSTACK "
					        "instruction.\n";
					exit(1);
				}
				{
					FuncStack *funcStack = new FuncStack(regs[0]);
					instruction = new Instruction(funcStack);
				}
				break;

			case FUNCSTACKCLEAN:
				if (count != 0) {
					cout << "Incorrect number of REGISTERS for FUNCSTACKCLEAN "
					        "instruction.\n";
					exit(1);
				}
				{
					FuncStackClean *funcStackClean = new FuncStackClean();
					instruction = new Instruction(funcStackClean);
				}
				break;

			case VARINITIATION:
				if (count != 1) {
					cout << "Incorrect number of REGISTERS for VARINITIATION "
					        "instruction.\n";
					exit(1);
				}
				{
					VariableInitiation *variableInitiation =
					    new VariableInitiation(regs[0], builder);
					instruction = new Instruction(variableInitiation);
				}
				break;
			default:
				cout << "Not implemented.\n";
				exit(0);
				break;
			};
			instructions.push_back(instruction);
			evaluated += instruction->evaluated;
		}
		Function *end() {
			instruction(InstructionType::FUNCSTACKCLEAN, 0);
			return this;
		};
		void lock() {
			locked = true;
			builder->push(evaluated);
		};
		void relock() {
			if (locked) {
				builder->push(evaluated);
			}
		};
		void add(LZString text) { evaluated += text; };
		LZString name;
		Type *funcType;
		bool locked;

	  private:
		vector<Instruction *> instructions;
		LZString evaluated;
		AssemblyBuilder *builder;
	};
	Function *FuncGet(LZString name) {
		for (auto i = 0; i < (signed)functions.size(); i++) {
			if (functions[i]->name == name) {
				return functions[i];
			}
		}
		return FuncGet("void");
	};
	Function *function(LZString name, Type *type) {
		functions.push_back(new Function(name, type, this));
		return functions[functions.size() - 1];
	};
	Function *function(LZString name, LZString type) {
		functions.push_back(new Function(name, TypeGet(type), this));
		return functions[functions.size() - 1];
	};
	Type *type(LZString name, ListType *list) {
		types.push_back(new Type(name, list, this));
		return types[types.size() - 1];
	};
	Type *type(LZString name) {
		LZString parsedName;
		ListType *list;
		bool nameDone;
		for (TINT i = 0; name[i] != '\0'; i++) {
			if (!nameDone) {
				if (name[i] != '[') {
					if (name[i + 1] == '\0') {
						list = new ListType(ListSizeType::NONE);
					}
					parsedName += name[i];
				} else {
					int size = 0;
					for (TINT j = 0; name[i + j] != '\0' && name[i + j] != ']';
					     i++) {
						i = i * 10;
						size += name[i + j] + 0;
					}
					i++;
					list = new ListType(ListSizeType::SIZED, i);
					nameDone = true;
				}
			}
			if (name[i] == '[') {
				int size = 0;
				for (TINT j = 0; name[i + j] != '\0' && name[i + j] != ']';
				     i++) {
					i = i * 10;
					size += name[i + j] + 0;
				}
			}
		}
		types.push_back(new Type(parsedName, list, this));
		return types[types.size() - 1];
	};
	void addBSS(LZString text) { bss += text; };
	void addData(LZString text) { data += text; };
	void push(LZString text) {
		edge += text;
		cout << text;
	};
	void end() {
		evaluated += edge + ".global _start"
		                    "\n"
		                    "_start:"
							"\n"
							"	ZS INIT"
		                    "\n"
		                    "	FUNCTION CALL Main"
		                    "\n"
		                    "	ZS END"
							"\n";
	};
	void subEnd() { evaluated += edge; };
	void defs() {
		type("void")->lock();
		type("byte")->lock();

		function("void", "void");
	};
	LZString get() { return head + bss + data + evaluated; };
	LZString subGet() { return edge; };
	LZString getEvaluated() { return evaluated; };
	void import(AssemblyBuilder *builder) {
		int oldFuncSize = functions.size();
		int oldTypeSize = types.size();
		functions.insert(functions.end(), builder->functions.begin(),
		                 builder->functions.end());
		types.insert(types.end(), builder->types.begin(), builder->types.end());
		for (int i = oldTypeSize; i < types.size(); i++) {
			types[i]->relock();
		}
		for (int i = oldFuncSize; i < functions.size(); i++) {
			if (functions[i]->name != "void")
				functions[i]->relock();
		}
	};

	LZString data;
	vector<Function *> functions;
	vector<Type *> types;
	int count;

  private:
	LZString evaluated;
	LZString head;
	LZString bss;
	LZString edge;
};

#endif
